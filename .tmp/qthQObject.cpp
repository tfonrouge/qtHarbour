/*
 * $Id: qthQObject.wip 130 2011-04-20 15:54:25Z tfonrouge $
 *
 * File autogenerated by Wip utility v0.1-151
 * Do not edit this file.
 *
 * (C) 2012. qtHarbour     http://sourceforge.net/projects/qth/
 * (C) 2012. Teo Fonrouge  <tfonrouge/at/gmail/dot/com>
 *
 */

#include "qtharbour.h"

#include <QObject>

/*
 * Wip: Dump Section INIT
 */

#include <QMetaObject>
#include <QMetaMethod>
#include "qth_DynSlot.h"
/*
 * Wip: Dump Section END
 */

/*
 * Wip: Dump Section INIT
 */

HB_FUNC_STATIC( HBCONNECT )
{
    QObject* object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );
    
    if( object )
    {
        if( HB_ISCHAR( 1 ) && hb_param( 2, HB_IT_BLOCK ) && qth_Is( 3, HB_IT_INTEGER, QTH_DEFAULT ) )
        {
            const char* szSignal = hb_parcx( 1 );
            PHB_ITEM pCodeBlock = hb_param( 2, HB_IT_BLOCK );

            if( pCodeBlock )
            {
                DynObject* dynObject;

                if( qth_itemListGet_PQTH_ITEM( object )->dynObject )
                {
                    dynObject = qth_itemListGet_PQTH_ITEM( object )->dynObject;
                }
                else
                {
                    dynObject = new DynObject( object );
                    qth_itemListGet_PQTH_ITEM( object )->dynObject = dynObject;
                }

                Qt::ConnectionType type = hb_param( 3, HB_IT_INTEGER ) ? (Qt::ConnectionType) hb_parni( 3 ) : (Qt::ConnectionType) Qt::AutoConnection;

                hb_retl( dynObject->connectDynSlot_Block( object, szSignal + 1, pCodeBlock, type ) );
            }
            return;
        }
        if( HB_ISCHAR( 1 ) && hb_param( 2, HB_IT_OBJECT ) && HB_ISCHAR( 3 ) && qth_Is( 4, HB_IT_INTEGER, QTH_DEFAULT ) )
        {
            const char* szSignal = hb_parcx( 1 );
            PHB_ITEM pReceiver = hb_param( 2, HB_IT_OBJECT );

            if( hb_objHasMsg( pReceiver, hb_parcx( 3 ) ) )
            {
                DynObject* dynObject;

                if( qth_itemListGet_PQTH_ITEM( object )->dynObject )
                {
                    dynObject = qth_itemListGet_PQTH_ITEM( object )->dynObject;
                }
                else
                {
                    dynObject = new DynObject( object );
                    qth_itemListGet_PQTH_ITEM( object )->dynObject = dynObject;
                }

                Qt::ConnectionType type = hb_param( 4, HB_IT_INTEGER ) ? (Qt::ConnectionType) hb_parni( 4 ) : (Qt::ConnectionType) Qt::AutoConnection;

                hb_retl( dynObject->connectDynSlot_Method( object, szSignal + 1, pReceiver, hb_parcx( 3 ), type ) );
            }
            return;
        }
        qth_errRT_PARAM();
    }
}
/*
 * Wip: Dump Section END
 */


/*
 * Wip: Class Creation & Object Instantiation Section INIT
 */

HB_FUNC( QOBJECT );
HB_FUNC_EXTERN( __CLSLOCKDEF );
HB_FUNC_EXTERN( HBCLASS );
HB_FUNC_EXTERN( QTHBASE );
HB_FUNC_STATIC( S_REGISTERMETHODS );
HB_FUNC_EXTERN( __CLSUNLOCKDEF );
HB_FUNC_EXTERN( __OBJHASMSG );
HB_FUNC_INITSTATICS();
HB_FUNC_EXTERN( QVARIANT ); // REQUEST'ed Class

HB_INIT_SYMBOLS_BEGIN( hb_vm_SymbolInit_QOBJECT )
{ "QOBJECT", {HB_FS_PUBLIC | HB_FS_FIRST | HB_FS_LOCAL}, {HB_FUNCNAME( QOBJECT )}, NULL },
{ "__CLSLOCKDEF", {HB_FS_PUBLIC}, {HB_FUNCNAME( __CLSLOCKDEF )}, NULL },
{ "NEW", {HB_FS_PUBLIC | HB_FS_MESSAGE}, {NULL}, NULL },
{ "HBCLASS", {HB_FS_PUBLIC}, {HB_FUNCNAME( HBCLASS )}, NULL },
{ "QTHBASE", { HB_FS_PUBLIC }, { HB_FUNCNAME( QTHBASE ) }, NULL },
{ "CREATE", {HB_FS_PUBLIC | HB_FS_MESSAGE}, {NULL}, NULL },
{ "S_REGISTERMETHODS", {HB_FS_STATIC | HB_FS_LOCAL}, {HB_FUNCNAME( S_REGISTERMETHODS )}, NULL },
{ "HCLASS", {HB_FS_PUBLIC | HB_FS_MESSAGE}, {NULL}, NULL },
{ "__CLSUNLOCKDEF", {HB_FS_PUBLIC}, {HB_FUNCNAME( __CLSUNLOCKDEF )}, NULL },
{ "INSTANCE", {HB_FS_PUBLIC | HB_FS_MESSAGE}, {NULL}, NULL },
{ "__OBJHASMSG", {HB_FS_PUBLIC}, {HB_FUNCNAME( __OBJHASMSG )}, NULL },
{ "INITCLASS", {HB_FS_PUBLIC | HB_FS_MESSAGE}, {NULL}, NULL },
{ "(_INITSTATICS_1)", {HB_FS_INITEXIT | HB_FS_LOCAL}, {hb_INITSTATICS}, NULL },
{ "QVARIANT", {HB_FS_PUBLIC}, {HB_FUNCNAME( QVARIANT )}, NULL }  // REQUEST'ed Class
HB_INIT_SYMBOLS_END( hb_vm_SymbolInit_QOBJECT )

HB_FUNC( QOBJECT )
{
    qthClassObjCreator( symbols, 1 );
}

HB_FUNC_INITSTATICS()
{
    qthInitStatics( symbols, 1 );
}
/*
 * Wip: Class Creation & Object Instantiation Section END
 */

/*
 * Wip: Method's Declaration Section INIT
 */
HB_FUNC_STATIC( NEW )
{
    /*
     * _public_functions_ : QObject ( QObject * parent = 0 )
     */
    if( ( hb_pcount() <= 1 ) && qth_Is( 1, "QObject", QTH_DEFAULT ) )
    {
        QObject* parent = hb_param( 1, HB_IT_OBJECT ) ? qth_parPtr<QObject>( 1 ) : ( QObject* ) 0;
        qth_itemPushReturn( QtH::QObject, new QObject( parent ) );
        return;
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( BLOCKSIGNALS )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  blockSignals ( bool block )
         */
        if( ( hb_pcount() == 1 ) && qth_Is( 1, HB_IT_LOGICAL ) )
        {
            hb_retl( p_object->blockSignals( hb_parl( 1 ) ) == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( CHILDREN )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : const QObjectList &  children () const
         */
        if( hb_pcount() == 0 )
        {
            // ! Don't know how to return type 'QObjectList'
            // qth_itemReturn( (PCPP_OBJECT)  & p_object->children(), "QObjectList" );
            qth_errRT_UNKNOWNOBJ( "QObject::children", "Don't know how to return type 'QObjectList'" ) ;
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC( QOBJECT_CONNECT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  connect ( const QObject * sender, const char * signal, const char * method, Qt::ConnectionType type = Qt::AutoConnection ) const
         */
        if( ( hb_pcount() <= 4 ) && qth_IsObject( 1, "QObject" ) && qth_Is( 2, HB_IT_STRING ) && qth_Is( 3, HB_IT_STRING ) && qth_IsIntType( 4, "Qt::ConnectionType", QTH_DEFAULT ) )
        {
            const QObject  * sender = static_cast<QObject *>( qth_par_QthObject( 1 ) );
            const char * signal = hb_parc( 2 );
            const char * method = hb_parc( 3 );
            hb_retl( p_object->connect( sender, signal, method, (Qt::ConnectionType) qth_par_IntType( 4, Qt::AutoConnection ) ) == true );
            return;
        }
    }
    /*
     * _static_public_members_ : bool  connect ( const QObject * sender, const char * signal, const QObject * receiver, const char * method, Qt::ConnectionType type = Qt::AutoConnection )
     */
    if( ( hb_pcount() <= 5 ) && qth_IsObject( 1, "QObject" ) && qth_Is( 2, HB_IT_STRING ) && qth_IsObject( 3, "QObject" ) && qth_Is( 4, HB_IT_STRING ) && qth_IsIntType( 5, "Qt::ConnectionType", QTH_DEFAULT ) )
    {
        const QObject  * sender = static_cast<QObject *>( qth_par_QthObject( 1 ) );
        const char * signal = hb_parc( 2 );
        const QObject  * receiver = static_cast<QObject *>( qth_par_QthObject( 3 ) );
        const char * method = hb_parc( 4 );
        hb_retl( QObject::connect( sender, signal, receiver, method, (Qt::ConnectionType) qth_par_IntType( 5, Qt::AutoConnection ) ) == true );
        return;
    }
    qth_errRT_PARAM();
}

HB_FUNC( QOBJECT_DISCONNECT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  disconnect ( const char * signal = 0, const QObject * receiver = 0, const char * method = 0 )
         */
        if( ( hb_pcount() <= 3 ) && qth_Is( 1, HB_IT_STRING, QTH_DEFAULT ) && qth_Is( 2, "QObject", QTH_DEFAULT ) && qth_Is( 3, HB_IT_STRING, QTH_DEFAULT ) )
        {
            const char* signal = hb_param( 1, HB_IT_STRING ) ? hb_parc( 1 ) : 0;
            const QObject* receiver = hb_param( 2, HB_IT_OBJECT ) ? qth_parConstPtr<QObject>( 2 ) : ( QObject* ) 0;
            const char* method = hb_param( 3, HB_IT_STRING ) ? hb_parc( 3 ) : 0;
            hb_retl( p_object->disconnect( signal, receiver, method ) == true );
            return;
        }
        /*
         * _public_functions_ : bool  disconnect ( const QObject * receiver, const char * method = 0 )
         */
        if( ( hb_pcount() <= 2 ) && qth_IsObject( 1, "QObject" ) && qth_Is( 2, HB_IT_STRING, QTH_DEFAULT ) )
        {
            const QObject  * receiver = static_cast<QObject *>( qth_par_QthObject( 1 ) );
            const char* method = hb_param( 2, HB_IT_STRING ) ? hb_parc( 2 ) : 0;
            hb_retl( p_object->disconnect( receiver, method ) == true );
            return;
        }
    }
    /*
     * _static_public_members_ : bool  disconnect ( const QObject * sender, const char * signal, const QObject * receiver, const char * method )
     */
    if( ( hb_pcount() == 4 ) && qth_IsObject( 1, "QObject" ) && qth_Is( 2, HB_IT_STRING ) && qth_IsObject( 3, "QObject" ) && qth_Is( 4, HB_IT_STRING ) )
    {
        const QObject  * sender = static_cast<QObject *>( qth_par_QthObject( 1 ) );
        const char * signal = hb_parc( 2 );
        const QObject  * receiver = static_cast<QObject *>( qth_par_QthObject( 3 ) );
        const char * method = hb_parc( 4 );
        hb_retl( QObject::disconnect( sender, signal, receiver, method ) == true );
        return;
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( DUMPOBJECTINFO )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  dumpObjectInfo ()
         */
        if( hb_pcount() == 0 )
        {
            p_object->dumpObjectInfo();
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( DUMPOBJECTTREE )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  dumpObjectTree ()
         */
        if( hb_pcount() == 0 )
        {
            p_object->dumpObjectTree();
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( DYNAMICPROPERTYNAMES )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : QList<QByteArray>  dynamicPropertyNames () const
         */
        if( hb_pcount() == 0 )
        {
            // ! Don't know how to return type 'QList'
            // qth_itemPushNewReturn( QtH::QList, new QList<QByteArray>( p_object->dynamicPropertyNames() ), "QList<QByteArray>" );
            qth_errRT_UNKNOWNOBJ( "QObject::dynamicPropertyNames", "Don't know how to return type 'QList'" ) ;
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( EVENT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : virtual bool  event ( QEvent * e )
         */
        if( ( hb_pcount() == 1 ) && qth_IsObject( 1, "QEvent" ) )
        {
            hb_retl( p_object->event( static_cast<QEvent *>( qth_par_QthObject( 1 ) ) ) == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( EVENTFILTER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : virtual bool  eventFilter ( QObject * watched, QEvent * event )
         */
        if( ( hb_pcount() == 2 ) && qth_IsObject( 1, "QObject" ) && qth_IsObject( 2, "QEvent" ) )
        {
            hb_retl( p_object->eventFilter( static_cast<QObject *>( qth_par_QthObject( 1 ) ), static_cast<QEvent *>( qth_par_QthObject( 2 ) ) ) == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( INHERITS )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  inherits ( const char * className ) const
         */
        if( ( hb_pcount() == 1 ) && qth_Is( 1, HB_IT_STRING ) )
        {
            const char * className = hb_parc( 1 );
            hb_retl( p_object->inherits( className ) == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( INSTALLEVENTFILTER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  installEventFilter ( QObject * filterObj )
         */
        if( ( hb_pcount() == 1 ) && qth_IsObject( 1, "QObject" ) )
        {
            p_object->installEventFilter( static_cast<QObject *>( qth_par_QthObject( 1 ) ) );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( ISWIDGETTYPE )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  isWidgetType () const
         */
        if( hb_pcount() == 0 )
        {
            hb_retl( p_object->isWidgetType() == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( KILLTIMER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  killTimer ( int id )
         */
        if( ( hb_pcount() == 1 ) && qth_Is( 1, HB_IT_INTEGER ) )
        {
            p_object->killTimer( hb_parni( 1 ) );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( METAOBJECT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : virtual const QMetaObject *  metaObject () const
         */
        if( hb_pcount() == 0 )
        {
            // ! Don't know how to return type 'QMetaObject'
            // qth_itemReturn( (PCPP_OBJECT) p_object->metaObject(), "QMetaObject" );
            qth_errRT_UNKNOWNOBJ( "QObject::metaObject", "Don't know how to return type 'QMetaObject'" ) ;
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( MOVETOTHREAD )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  moveToThread ( QThread * targetThread )
         */
        if( ( hb_pcount() == 1 ) && qth_IsObject( 1, "QThread" ) )
        {
            p_object->moveToThread( static_cast<QThread *>( qth_par_QthObject( 1 ) ) );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( OBJECTNAME )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : QString  objectName () const
         */
        if( hb_pcount() == 0 )
        {
            qth_ret_QString( p_object->objectName() );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( PARENT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : QObject *  parent () const
         */
        if( hb_pcount() == 0 )
        {
            qth_itemReturn( (PCPP_OBJECT) p_object->parent(), "QObject" );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( PROPERTY )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : QVariant  property ( const char * name ) const
         */
        if( ( hb_pcount() == 1 ) && qth_Is( 1, HB_IT_STRING ) )
        {
            const char * name = hb_parc( 1 );
            qth_itemPushNewReturn( QtH::QVariant, new QVariant( p_object->property( name ) ), "QVariant" );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( REMOVEEVENTFILTER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  removeEventFilter ( QObject * obj )
         */
        if( ( hb_pcount() == 1 ) && qth_IsObject( 1, "QObject" ) )
        {
            p_object->removeEventFilter( static_cast<QObject *>( qth_par_QthObject( 1 ) ) );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( SETOBJECTNAME )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  setObjectName ( const QString & name )
         */
        if( ( hb_pcount() == 1 ) && qth_IsString( 1 ) )
        {
            QString name =  qth_par_QString( 1 );
            p_object->setObjectName( name );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( SETPARENT )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : void  setParent ( QObject * parent )
         */
        if( ( hb_pcount() == 1 ) && qth_IsObject( 1, "QObject" ) )
        {
            p_object->setParent( static_cast<QObject *>( qth_par_QthObject( 1 ) ) );
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( SETPROPERTY )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  setProperty ( const char * name, const QVariant & value )
         */
        if( ( hb_pcount() == 2 ) && qth_Is( 1, HB_IT_STRING ) && qth_IsObject( 2, "QVariant" ) )
        {
            const char * name = hb_parc( 1 );
            const QVariant & value = * static_cast<QVariant *>( qth_par_QthObject( 2 ) );
            hb_retl( p_object->setProperty( name, value ) == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( SIGNALSBLOCKED )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : bool  signalsBlocked () const
         */
        if( hb_pcount() == 0 )
        {
            hb_retl( p_object->signalsBlocked() == true );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( STARTTIMER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : int  startTimer ( int interval )
         */
        if( ( hb_pcount() == 1 ) && qth_Is( 1, HB_IT_INTEGER ) )
        {
            hb_retni( p_object->startTimer( hb_parni( 1 ) ) );
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( THREAD )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_functions_ : QThread *  thread () const
         */
        if( hb_pcount() == 0 )
        {
            // ! Don't know how to return type 'QThread'
            // qth_itemReturn( (PCPP_OBJECT) p_object->thread(), "QThread" );
            qth_errRT_UNKNOWNOBJ( "QObject::thread", "Don't know how to return type 'QThread'" ) ;
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC_STATIC( DELETELATER )
{
    QObject* p_object = static_cast<QObject *> ( qth_itemListGet_CPP( hb_stackSelfItem() ) );

    if( p_object )
    {
        /*
         * _public_slots_ : void  deleteLater ()
         */
        if( hb_pcount() == 0 )
        {
            p_object->deleteLater();
            hb_ret();
            return;
        }
    }
    qth_errRT_PARAM();
}

HB_FUNC( QOBJECT_STATICMETAOBJECT )
{
    /*
     * _static_public_members_ : const QMetaObject  staticMetaObject
     */
    if( hb_pcount() == 0 )
    {
        // ! Don't know how to return type 'QMetaObject'
        // qth_itemPushNewReturn( QtH::QMetaObject, new QMetaObject( QObject::staticMetaObject ), "QMetaObject" );
        qth_errRT_UNKNOWNOBJ( "QObject::staticMetaObject", "Don't know how to return type 'QMetaObject'" ) ;
        return;
    }
    qth_errRT_PARAM();
}

HB_FUNC( QOBJECT_TR )
{
    /*
     * _static_public_members_ : QString  tr ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
     */
    if( ( hb_pcount() <= 3 ) && qth_Is( 1, HB_IT_STRING ) && qth_Is( 2, HB_IT_STRING, QTH_DEFAULT ) && qth_Is( 3, HB_IT_INTEGER, QTH_DEFAULT ) )
    {
        const char * sourceText = hb_parc( 1 );
        const char* disambiguation = hb_param( 2, HB_IT_STRING ) ? hb_parc( 2 ) : 0;
        int n = hb_param( 3, HB_IT_INTEGER ) ? hb_parni( 3 ) : -1;
        qth_ret_QString( QObject::tr( sourceText, disambiguation, n ) );
        return;
    }
    qth_errRT_PARAM();
}

HB_FUNC( QOBJECT_TRUTF8 )
{
    /*
     * _static_public_members_ : QString  trUtf8 ( const char * sourceText, const char * disambiguation = 0, int n = -1 )
     */
    if( ( hb_pcount() <= 3 ) && qth_Is( 1, HB_IT_STRING ) && qth_Is( 2, HB_IT_STRING, QTH_DEFAULT ) && qth_Is( 3, HB_IT_INTEGER, QTH_DEFAULT ) )
    {
        const char * sourceText = hb_parc( 1 );
        const char* disambiguation = hb_param( 2, HB_IT_STRING ) ? hb_parc( 2 ) : 0;
        int n = hb_param( 3, HB_IT_INTEGER ) ? hb_parni( 3 ) : -1;
        qth_ret_QString( QObject::trUtf8( sourceText, disambiguation, n ) );
        return;
    }
    qth_errRT_PARAM();
}

/*
 * Wip: Method's Declaration Section END
 */

/*
 * Wip: Register Harbour Method's Section INIT
 */
HB_FUNC_STATIC( S_REGISTERMETHODS )
{
    HB_USHORT uiClass = hb_itemGetNI( hb_param( 1, HB_IT_NUMERIC ) );

    hb_clsAdd( uiClass, "HBCONNECT"           , HB_FUNCNAME( HBCONNECT                ) );
    hb_clsAdd( uiClass, "NEW"                 , HB_FUNCNAME( NEW                      ) );
    hb_clsAdd( uiClass, "BLOCKSIGNALS"        , HB_FUNCNAME( BLOCKSIGNALS             ) );
    hb_clsAdd( uiClass, "CHILDREN"            , HB_FUNCNAME( CHILDREN                 ) );
    hb_clsAdd( uiClass, "CONNECT"             , HB_FUNCNAME( QOBJECT_CONNECT          ) );
    hb_clsAdd( uiClass, "DISCONNECT"          , HB_FUNCNAME( QOBJECT_DISCONNECT       ) );
    hb_clsAdd( uiClass, "DUMPOBJECTINFO"      , HB_FUNCNAME( DUMPOBJECTINFO           ) );
    hb_clsAdd( uiClass, "DUMPOBJECTTREE"      , HB_FUNCNAME( DUMPOBJECTTREE           ) );
    hb_clsAdd( uiClass, "DYNAMICPROPERTYNAMES", HB_FUNCNAME( DYNAMICPROPERTYNAMES     ) );
    hb_clsAdd( uiClass, "EVENT"               , HB_FUNCNAME( EVENT                    ) );
    hb_clsAdd( uiClass, "EVENTFILTER"         , HB_FUNCNAME( EVENTFILTER              ) );
    hb_clsAdd( uiClass, "INHERITS"            , HB_FUNCNAME( INHERITS                 ) );
    hb_clsAdd( uiClass, "INSTALLEVENTFILTER"  , HB_FUNCNAME( INSTALLEVENTFILTER       ) );
    hb_clsAdd( uiClass, "ISWIDGETTYPE"        , HB_FUNCNAME( ISWIDGETTYPE             ) );
    hb_clsAdd( uiClass, "KILLTIMER"           , HB_FUNCNAME( KILLTIMER                ) );
    hb_clsAdd( uiClass, "METAOBJECT"          , HB_FUNCNAME( METAOBJECT               ) );
    hb_clsAdd( uiClass, "MOVETOTHREAD"        , HB_FUNCNAME( MOVETOTHREAD             ) );
    hb_clsAdd( uiClass, "OBJECTNAME"          , HB_FUNCNAME( OBJECTNAME               ) );
    hb_clsAdd( uiClass, "PARENT"              , HB_FUNCNAME( PARENT                   ) );
    hb_clsAdd( uiClass, "PROPERTY"            , HB_FUNCNAME( PROPERTY                 ) );
    hb_clsAdd( uiClass, "REMOVEEVENTFILTER"   , HB_FUNCNAME( REMOVEEVENTFILTER        ) );
    hb_clsAdd( uiClass, "SETOBJECTNAME"       , HB_FUNCNAME( SETOBJECTNAME            ) );
    hb_clsAdd( uiClass, "SETPARENT"           , HB_FUNCNAME( SETPARENT                ) );
    hb_clsAdd( uiClass, "SETPROPERTY"         , HB_FUNCNAME( SETPROPERTY              ) );
    hb_clsAdd( uiClass, "SIGNALSBLOCKED"      , HB_FUNCNAME( SIGNALSBLOCKED           ) );
    hb_clsAdd( uiClass, "STARTTIMER"          , HB_FUNCNAME( STARTTIMER               ) );
    hb_clsAdd( uiClass, "THREAD"              , HB_FUNCNAME( THREAD                   ) );
    hb_clsAdd( uiClass, "DELETELATER"         , HB_FUNCNAME( DELETELATER              ) );
    hb_clsAdd( uiClass, "STATICMETAOBJECT"    , HB_FUNCNAME( QOBJECT_STATICMETAOBJECT ) );
    hb_clsAdd( uiClass, "TR"                  , HB_FUNCNAME( QOBJECT_TR               ) );
    hb_clsAdd( uiClass, "TRUTF8"              , HB_FUNCNAME( QOBJECT_TRUTF8           ) );
}
/*
 * Wip: Register Harbour Method's Section END
 */
